Nginx 可以将流量发送到不同的代理服务器，或者根据请求 URI 提供不同的文件。通过在 server 指令中使用 location 指令实现这些功能。 
例如，可以在虚拟服务器中定义 3 个 location块，将一部分请求发到被代理的服务器，另一部分请求发到另一个被代理的服务器，其他请求则映射到本地的文件系统。 

Nginx 会根据 location 指令的参数来测试请求的 URI，并使用匹配到的 location 指令。location 块通常可以嵌套，实现对请求的分组处理。 

location 指令有两种参数：前缀字符串（路径名）和正则表达式。要匹配前缀字符串的请求 URI 必须以这个前缀字符串开头才会匹配成功。

1 前缀字符串（路径名）
下面的 location 指令参数使用了路径名，请求 URI 要匹配这个 location，就必须以 /some/path/开头，比如 /some/path/document.html。而 /my-site/some/path 就不匹配。
	location /some/path/ {
		...
	}

2 正则表达式
	语法规则： location [=|~|~*|^~] /uri/ { … }
	前缀字符串及优先级:
		=：精确匹配，优先级最高。如果找到了这个精确匹配，则停止查找。
		^~：URI 以某个常规字符串开头，不是正则匹配
		~：区分大小写的正则匹配
		~*：不区分大小写的正则匹配
		!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则
		/：通用匹配, 优先级最低。任何请求都会匹配到这个规则

	优先级为： = > 完整路径 > ^~ > ~  ~*  !~   !~* > 部分起始路径 > /





			/ 通用匹配，任何请求都会匹配到。
多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：
首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。
 
	
	
下面的例子中，如果请求 URI 中的任何位置出现 .html 或 .htm 就匹配成功：
	location ~ \.html? {
		...
	}

3 location 匹配原则
为了找出最匹配 URI 的 location，Nginx 会先比较前缀字符串（路径名），再比较正则表达式。 
正则表达式的优先级较高，除非使用 ^? 修饰符。在前缀字符串中，Nginx 选择最特定的字符串（即最长和最完整的字符串）。 下面给出了选择处理请求的位置的确切逻辑：

	1 用所有的前缀字符串测试 URI。
	2 等号 = 定义了前缀字符串和 URI 的精确匹配关系。如果找到了这个精确匹配，则停止查找。
	3 如果 ^~ 修饰符预先匹配到最长的前缀字符串，则不检查正则表达式。
	4 存储最长的匹配前缀字符串。
	5 用正则表达式测试 URI。
	6 匹配到第一个正则表达式后停止查找，使用对应的 location。
	7 如果没有匹配到正则表达式，则使用之前存储的前缀字符串对应的 location。
	8 等号 = 最常见的用途就是 / (forward slash)。如果对 / 的请求很多，可以把 = / 指定为 location 的参数来提高响应速度。因为在第一次比较之后就停止搜索匹配。

location = / {
    ...
}

4 root 指令和 proxy_pass 指令
location 上下文中可以定义处理请求（提供静态文件或转发请求给被代理的服务器）的指令。

server {
    # 响应静态文件
    location /images/ {
        root /data;
    }
    # 转发请求到 http://www.example.com
    location / {
        proxy_pass http://www.example.com;
    }
}

4.1 root 指令
root 指令指定静态文件在文件系统中的路径。请求的 URI 中，和 location 相关的部分会和 root 指定的路径组合成完整的目录名和文件名，从而获取到静态文件。例如，上面的例子中对 /images/example.png 的请求，会对应文件 /data/images/example.png。

4.2 proxy_pass 指令
proxy_pass 指令将请求转发给和 URL 相关联的被代理的服务器，然后把被代理的服务器的响应转发给客户端。上面的例子中，所有 URI 不以 /images/ 开头的请求，都会被转发给被代理的服务器。










