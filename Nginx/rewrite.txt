ReWrite语法
	重写规则语法： rewrite 正则 替换 标志位
	syntax: rewrite regex replacement [flag]
	Context: server, location, if

flag标志：
	last C 基本上都用这个Flag。
		结束当前的请求处理，用替换后的URI重新匹配location；
		可理解为重写（rewrite）后，发起了一个新请求，进入server模块，匹配location；
		如果重新匹配循环的次数超过10次，nginx会返回500错误；
		返回302 http状态码 ；
		浏览器地址栏显示重地向后的url
		相当于Apache的[L]标记，表示rewrite

	break C 中止Rewirte，不在继续匹配
		结束当前的请求处理，使用当前资源，不在执行location里余下的语句；
		返回302 http状态码 ；
		浏览器地址栏显示重地向后的url

	redirect C 返回临时重定向的HTTP状态302
		临时跳转，返回302 http状态码；
		浏览器地址栏显示重地向后的url

	permanent C 返回永久重定向的HTTP状态301
		永久跳转，返回301 http状态码；
		浏览器地址栏显示重定向后的url

因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解：

last一般写在server和if中，而break一般使用在location中
last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配
break和last都能组织继续执行后面的rewrite指令

1、下面是可以用来判断的表达式：
	-f和!-f用来判断是否存在文件
	-d和!-d用来判断是否存在目录
	-e和!-e用来判断是否存在文件或目录
	-x和!-x用来判断文件是否可执行

2、下面是可以用作判断的全局变量
	$args #这个变量等于请求行中的参数。
	$content_length #请求头中的Content-length字段。
	$content_type #请求头中的Content-Type字段。
	$document_root #当前请求在root指令中指定的值。
	$host #请求主机头字段，否则为服务器名称。
	$http_user_agent #客户端agent信息
	$http_cookie #客户端cookie信息
	$limit_rate #这个变量可以限制连接速率。
	$request_body_file #客户端请求主体信息的临时文件名。
	$request_method #客户端请求的动作，通常为GET或POST。
	$remote_addr #客户端的IP地址。
	$remote_port #客户端的端口。
	$remote_user #已经经过Auth Basic Module验证的用户名。
	$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。
	$query_string #与$args相同。
	$scheme #HTTP方法（如http，https）。
	$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
	$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。
	$server_name #服务器名称。
	$server_port #请求到达服务器的端口号。
	$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。
	$uri #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
	$document_uri #与$uri相同。
	
例：http://localhost:88/test1/test2/test.php
$host：localhost
$server_port：88
$request_uri：http://localhost:88/test1/test2/test.php
$document_uri：/test1/test2/test.php
$document_root：D:\nginx/html
$request_filename：D:\nginx/html/test1/test2/test.php


syntax: rewrite regex replacement [flag]
Context: server, location, if

如果正则表达式（regex）匹配到了请求的URI（request URI），这个URI会被后面的replacement替换
rewrite的定向会根据他们在配置文件中出现的顺序依次执行

通过使用flag可以终止定向后进一步的处理

如果replacement以“http://”, “https://”, or “$scheme”开头，处理将会终止，请求结果会以重定向的形式返回给客户端（client）

如果replacement字符串里有新的request参数，那么之前的参数会附加到其后面，如果要避免这种情况，那就在replacement字符串后面加上“？”，eg：
 rewrite ^/users/(.*)$ /show?user=$1? last;=
如果正则表达式（regex）里包含“}” or “;”字符，需要用单引号或者双引号把正则表达式引起来

要把 http://www.test.com/a/b?id=123 的一条链接转换成 http://www.test.com/p-123.html

在nginx中是有特殊逻辑，它用$query_string来表示问号以后的字符，即"id=123"

if ($request_uri ~* "^/a/b\?id=(\d+)$") {
                set $myarg1 $1;
                rewrite .* http://www.test.com/p-$myarg1.html? permanent;
        }

注意，set $myarg1 $1; 这句话不能少，不能直接用$1，会出错的。


重写规则语法： rewrite 正则 替换 标志位

(1). 任何重写规则第一部分肯定是 正则表达式
可以用()来捕获正则表达式，然后在rewrite后面就用 $[d+] 来用这个正则表达式；比如：

^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$   ---->http://xxxx.com/images/aa/abc01/test.gif   
#其中   
$1=([a-z]{2})      #$1=aa  
$2=([a-z0-9]{5})   #$2=abc01  
$3=(.*)            #$3=test  
$4=(png|jpg|gif)   #$4=gif
上面的4个地段都是query 串中匹配的字符串  

(2). 重写规则的第二部分是URI(rewrite 重写后url)

query 请求串被改写，包括上面正则表达式获取的参数字段和nginx 相关的配置，

/data?file=$3.$4   # rewrite之后的query http://data?file=test.gif
rewrite 之后会返回给客户端301 或者302  [ 会不会返回200]

(3). 重写规则的第三部分是：尾部的标记  flag last return break
laster 标记之后会从新loaction ，继续rewrite 最多10次

rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4 last;  
#<pre name="code" class="html">http://xxxx.com/images/aa/abc01/test.gif   -----rewrite---> http://data?file=test.gif

break标记是直接跳槽rewrite和localtion 进行query的处理
if ($bwhog) {  
    limit_rate 300k;  
    break;  
}
return标记停止rewrite 处理指令，进而控制主HTTP 模块处理请求，也就是HTTP请求也不处理了，直接给client 返回(结合error0page，)

location = /image404.html {  
    return 404 "image not found\n";  
}
(4). 整个过程的实例
http {  
    server {  
        root /home/www;  
   
        location / {  
                # 重写规则信息  
                error_log logs/rewrite.log notice;   
                # 注意这里要用‘’单引号引起来，避免{}  
                rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4;  
                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行  
                set $image_file $3;  
                set $image_type $4;  
        }  
   
        location /data {  
                 
                rewrite /data?(.*) /error/img=$1 break;  #break 就是最后的rewrite 结果，不会再次遍历localtion啦  
        }  
        location = /error/ {  
                # 图片不存在返回特定的信息  
                return 404 "image not found\n";  #如果是return HTTP 直接返回403 302 等状态码  
        }  
}






